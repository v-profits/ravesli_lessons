//77.4
#include <iostream>


int main()
{
	const int length = 9; //const - обязателен
	int arr[length] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
	bool flag = false;
	int count = 0;

	for (int i = 0; i < length - 1; ++i) {
		flag = false;
		for (int j = 0; j < length - i - 1; ++j)
			if (arr[j] > arr[j + 1]) {
				std::swap(arr[j], arr[j + 1]);
				flag = true;
			}
		++count;
		if (!flag) break;
	}
	for (int k = 0; k < length; ++k)
		std::cout << arr[k] << ' ';
	std::cout << '\n' << count;

	return 0;
}

/*
Реализуйте следующие два решения оптимизации алгоритма сортировки пузырьком, который вы написали в предыдущем задании:
   Обратите внимание, с каждым выполнением сортировки пузырьком наибольшее значения в массиве «пузырится» до конца. 
   После первой итерации последний элемент массива уже отсортирован. После второй итерации отсортирован предпоследний элемент массива и т.д. 
   С каждой новой итерацией нам не нужно перепроверять элементы, которые уже были отсортированы. Измените свой цикл соответствующим образом.
   Если на протяжении всей итерации не выполнится ни одной замены, то мы знаем, что массив уже отсортирован. 
   Внедрите проверку того, были ли сделаны какие-либо замены в текущей итерации, и, если нет — завершите выполнение цикла. 
   Если цикл был завершен, то выведите информацию о том, на какой итерации сортировка элементов завершилась.

Пример результата выполнения вашей программы:

Early termination on iteration: 8
1 2 3 4 5 6 7 8 9
*/